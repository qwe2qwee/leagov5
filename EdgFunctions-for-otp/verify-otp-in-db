import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
// Enhanced CORS headers for better security
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type, x-requested-with, accept",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
  "Access-Control-Max-Age": "86400",
};
// Environment variables validation
const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");
const AUTHENTICA_API_KEY =
  "$2y$10$P7V123TDwDF5bGBqP3D3f.LXr8NyXfu5Vo6CAilmL66tHS9w6jPPq";
const NODE_ENV = Deno.env.get("NODE_ENV") || "production";
// Validate required environment variables
if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY || !AUTHENTICA_API_KEY) {
  const missingVars = [];
  if (!SUPABASE_URL) missingVars.push("SUPABASE_URL");
  if (!SUPABASE_SERVICE_KEY) missingVars.push("SUPABASE_SERVICE_KEY");
  if (!AUTHENTICA_API_KEY) missingVars.push("AUTHENTICA_API_KEY");
  console.error("‚ùå Missing required environment variables:", missingVars);
  if (NODE_ENV !== "production") {
    throw new Error(`Missing environment variables: ${missingVars.join(", ")}`);
  }
}
// Initialize Supabase client with proper error handling
let supabase;
try {
  supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);
  console.log("‚úÖ Supabase client initialized for verify-otp");
} catch (error) {
  console.error("‚ùå Failed to initialize Supabase client:", error);
  throw error;
}
// Configuration constants
const CONFIG = {
  TEMP_PASSWORD_LENGTH: 16,
  REQUEST_TIMEOUT: 30000,
  MAX_OTP_ATTEMPTS: 5,
};
// Enhanced secure password generator with better entropy
function generateTempPassword(length = CONFIG.TEMP_PASSWORD_LENGTH) {
  // Use more secure character set with better balance
  const lowercase = "abcdefghijklmnopqrstuvwxyz";
  const uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const numbers = "0123456789";
  const symbols = "!@#$%^&*()-_+=[]{}|;:,.<>?";
  const allChars = lowercase + uppercase + numbers + symbols;
  // Ensure at least one character from each category
  const mandatoryChars = [
    lowercase[crypto.getRandomValues(new Uint8Array(1))[0] % lowercase.length],
    uppercase[crypto.getRandomValues(new Uint8Array(1))[0] % uppercase.length],
    numbers[crypto.getRandomValues(new Uint8Array(1))[0] % numbers.length],
    symbols[crypto.getRandomValues(new Uint8Array(1))[0] % symbols.length],
  ];
  // Generate remaining characters
  const remainingLength = length - mandatoryChars.length;
  const randomBytes = crypto.getRandomValues(new Uint8Array(remainingLength));
  const remainingChars = Array.from(
    randomBytes,
    (byte) => allChars[byte % allChars.length]
  );
  // Combine and shuffle
  const allPasswordChars = [...mandatoryChars, ...remainingChars];
  // Fisher-Yates shuffle for secure randomization
  for (let i = allPasswordChars.length - 1; i > 0; i--) {
    const randomIndex = crypto.getRandomValues(new Uint8Array(1))[0] % (i + 1);
    [allPasswordChars[i], allPasswordChars[randomIndex]] = [
      allPasswordChars[randomIndex],
      allPasswordChars[i],
    ];
  }
  return allPasswordChars.join("");
}
// Enhanced phone number normalization (same logic as send-otp)
function normalizePhoneNumber(phone) {
  try {
    if (!phone || typeof phone !== "string" || phone.length > 20) {
      return {
        normalized: "",
        isValid: false,
        error: "Invalid phone number format",
      };
    }
    // Remove all whitespace and non-digit characters except +
    let normalized = phone.replace(/[^\d+]/g, "");
    // Handle different Saudi number formats
    if (normalized.startsWith("+966")) {
      // Already in international format
    } else if (normalized.startsWith("00966")) {
      normalized = "+" + normalized.substring(2);
    } else if (normalized.startsWith("966")) {
      normalized = "+" + normalized;
    } else if (normalized.startsWith("0")) {
      normalized = "+966" + normalized.substring(1);
    } else if (normalized.startsWith("5")) {
      normalized = "+966" + normalized;
    } else {
      return {
        normalized: "",
        isValid: false,
        error: "Invalid phone number format",
      };
    }
    // Validate Saudi mobile number pattern
    const saudiMobileRegex = /^\+966(5[0|3-9])(\d{7})$/;
    if (!saudiMobileRegex.test(normalized)) {
      return {
        normalized: "",
        isValid: false,
        error: "Invalid Saudi mobile number format",
      };
    }
    return {
      normalized,
      isValid: true,
    };
  } catch (error) {
    return {
      normalized: "",
      isValid: false,
      error: "Phone validation failed",
    };
  }
}
// Error response helper
function createErrorResponse(error, status = 400, details) {
  const response = {
    success: false,
    error,
    timestamp: new Date().toISOString(),
    ...(NODE_ENV === "development" &&
      details && {
        details,
      }),
  };
  return new Response(JSON.stringify(response), {
    status,
    headers: {
      ...corsHeaders,
      "Content-Type": "application/json",
    },
  });
}
// Success response helper
function createSuccessResponse(data) {
  return new Response(
    JSON.stringify({
      success: true,
      timestamp: new Date().toISOString(),
      ...data,
    }),
    {
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json",
      },
    }
  );
}
// Timeout wrapper for fetch requests
async function fetchWithTimeout(
  url,
  options,
  timeout = CONFIG.REQUEST_TIMEOUT
) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === "AbortError") {
      throw new Error(`Request timeout after ${timeout}ms`);
    }
    throw error;
  }
}
function validateRequestBody(body) {
  if (!body || typeof body !== "object") {
    return {
      validated: {},
      error: "Request body must be a valid JSON object",
    };
  }
  const { phone, otp_code, token, session_id } = body;
  const code = otp_code || token;
  if (!phone || typeof phone !== "string") {
    return {
      validated: {},
      error: "Phone number is required",
    };
  }
  if (!code || typeof code !== "string") {
    return {
      validated: {},
      error: "OTP code is required",
    };
  }
  // Basic OTP format validation
  if (!/^\d{4,8}$/.test(code)) {
    return {
      validated: {},
      error: "Invalid OTP format",
    };
  }
  return {
    validated: {
      phone: phone,
      otp_code: code,
      session_id: typeof session_id === "string" ? session_id : undefined,
    },
  };
}
// Get client IP for logging
function getClientIP(request) {
  return (
    request.headers.get("x-forwarded-for")?.split(",")[0]?.trim() ||
    request.headers.get("x-real-ip") ||
    request.headers.get("cf-connecting-ip") ||
    "unknown"
  );
}
serve(async (req) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    console.log("üîÑ CORS preflight request for verify-otp");
    return new Response(null, {
      headers: corsHeaders,
    });
  }
  // Only accept POST requests
  if (req.method !== "POST") {
    return createErrorResponse("Method not allowed. Use POST.", 405);
  }
  const clientIP = getClientIP(req);
  const userAgent = req.headers.get("user-agent") || "unknown";
  console.log(`üì• Verify OTP request from IP: ${clientIP.substring(0, 8)}...`);
  try {
    // Parse and validate request body
    let body;
    try {
      const requestText = await req.text();
      if (!requestText.trim()) {
        return createErrorResponse("Request body cannot be empty");
      }
      body = JSON.parse(requestText);
    } catch (parseError) {
      console.error("‚ùå JSON parse error:", parseError);
      return createErrorResponse("Invalid JSON in request body");
    }
    // Validate request structure
    const validation = validateRequestBody(body);
    if (validation.error) {
      return createErrorResponse(validation.error);
    }
    const { phone, otp_code, session_id } = validation.validated;
    console.log(`üì± Verifying OTP for phone ending in ...${phone.slice(-4)}`);
    // Normalize phone number
    const phoneValidation = normalizePhoneNumber(phone);
    if (!phoneValidation.isValid) {
      console.log(`‚ùå Phone validation failed: ${phoneValidation.error}`);
      return createErrorResponse(phoneValidation.error);
    }
    const normalizedPhone = phoneValidation.normalized;
    console.log(`üì± Normalized phone: ${normalizedPhone}`);
    // 1. Verify OTP with Authentica API
    console.log("üîê Verifying OTP with Authentica...");
    let authenticaResponse;
    try {
      authenticaResponse = await fetchWithTimeout(
        "https://api.authentica.sa/api/v2/verify-otp",
        {
          method: "POST",
          headers: {
            "X-Authorization": AUTHENTICA_API_KEY,
            Accept: "application/json",
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            phone: normalizedPhone,
            otp: otp_code,
          }),
        }
      );
    } catch (fetchError) {
      console.error("‚ùå Authentica API connection failed:", fetchError);
      // Update OTP request status if session_id provided
      if (session_id) {
        try {
          await supabase
            .from("otp_requests")
            .update({
              status: "failed",
              error: fetchError.message,
              updated_at: new Date().toISOString(),
            })
            .eq("authentica_session_id", session_id);
        } catch (updateError) {
          console.warn("‚ö†Ô∏è Failed to update OTP request status:", updateError);
        }
      }
      return createErrorResponse(
        "OTP verification service temporarily unavailable",
        502
      );
    }
    console.log(
      `üì° Authentica verification response: ${authenticaResponse.status}`
    );
    // Parse Authentica response
    let authenticaData;
    try {
      authenticaData = await authenticaResponse.json();
    } catch (parseError) {
      console.error("‚ùå Invalid Authentica response format");
      return createErrorResponse("Invalid OTP verification response", 502);
    }
    // Check if OTP verification failed
    if (!authenticaResponse.ok || !authenticaData.status) {
      console.error("‚ùå OTP verification failed:", authenticaData);
      // Update OTP request status if session_id provided
      if (session_id) {
        try {
          await supabase
            .from("otp_requests")
            .update({
              status: "failed",
              error: "Invalid OTP code",
              updated_at: new Date().toISOString(),
            })
            .eq("authentica_session_id", session_id);
        } catch (updateError) {
          console.warn("‚ö†Ô∏è Failed to update OTP request status:", updateError);
        }
      }
      const errorMessage =
        authenticaData.errors?.[0]?.message ||
        authenticaData.message ||
        "Invalid OTP code. Please try again.";
      return createErrorResponse(errorMessage, 400);
    }
    console.log("‚úÖ OTP verified successfully with Authentica");
    // 2. Find user in profiles table
    console.log("üë§ Looking up user profile...");
    const { data: existingUser, error: fetchProfileError } = await supabase
      .from("profiles")
      .select("user_id, email, phone, is_verified")
      .eq("phone", normalizedPhone)
      .single();
    if (fetchProfileError || !existingUser?.user_id) {
      console.error("‚ùå User not found:", fetchProfileError);
      return createErrorResponse("User not found. Please register first.", 404);
    }
    const userId = existingUser.user_id;
    console.log(`üë§ Found user: ${userId}`);
    // 3. Generate secure temporary password
    const tempPassword = generateTempPassword();
    console.log("üîë Generated secure temporary password");
    // 4. Update user password in Supabase Auth
    console.log("üîê Setting temporary password in Auth...");
    const { data: updatedUser, error: updateUserError } =
      await supabase.auth.admin.updateUserById(userId, {
        password: tempPassword,
        phone: normalizedPhone,
        phone_confirm: true,
        user_metadata: {
          phone_verified: true,
          temp_password_set_at: new Date().toISOString(),
        },
      });
    if (updateUserError) {
      console.error("‚ùå Failed to update auth user password:", updateUserError);
      return createErrorResponse("Failed to set temporary password", 500);
    }
    console.log("‚úÖ Temporary password set successfully");
    // 5. Update verification status in profiles table
    console.log("üìù Updating profile verification status...");
    const { error: profileUpdateError } = await supabase
      .from("profiles")
      .update({
        is_verified: true,
        phone_verified_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      })
      .eq("user_id", userId);
    if (profileUpdateError) {
      console.warn(
        "‚ö†Ô∏è Profile update warning (non-critical):",
        profileUpdateError
      );
    } else {
      console.log("‚úÖ Profile verification status updated");
    }
    // 6. Update OTP request status if session_id provided
    if (session_id) {
      console.log("üìã Updating OTP request status...");
      const { error: otpUpdateError } = await supabase
        .from("otp_requests")
        .update({
          status: "verified",
          user_id: userId,
          verified_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        })
        .eq("authentica_session_id", session_id);
      if (otpUpdateError) {
        console.warn(
          "‚ö†Ô∏è OTP request update warning (non-critical):",
          otpUpdateError
        );
      } else {
        console.log("‚úÖ OTP request status updated");
      }
    }
    // 7. Prepare success response with temporary password
    const responseData = {
      message:
        "OTP verified successfully. Temporary password created ‚Äî returned once.",
      user: {
        id: userId,
        email: existingUser.email,
        phone: normalizedPhone,
        is_verified: true,
      },
      temp_password: tempPassword,
      // Additional security info
      security_info: {
        temp_password_expires: "24 hours",
        change_password_required: true,
        verified_at: new Date().toISOString(),
      },
    };
    console.log("‚úÖ OTP verification completed successfully");
    // Log successful verification (without password)
    try {
      await supabase.from("auth_logs").insert({
        user_id: userId,
        action: "otp_verification_success",
        ip_address: clientIP,
        user_agent: userAgent,
        created_at: new Date().toISOString(),
      });
    } catch (logError) {
      console.warn("‚ö†Ô∏è Failed to log verification (non-critical):", logError);
    }
    return createSuccessResponse(responseData);
  } catch (error) {
    console.error("‚ùå Unexpected error in verify-otp:", error);
    // Log error for monitoring
    try {
      await supabase.from("error_logs").insert({
        function_name: "verify-otp",
        error_message: error.message,
        error_stack: error.stack,
        ip_address: getClientIP(req),
        user_agent: req.headers.get("user-agent"),
        created_at: new Date().toISOString(),
      });
    } catch (logError) {
      console.error("‚ùå Failed to log error:", logError);
    }
    return createErrorResponse(
      "Internal server error",
      500,
      NODE_ENV === "development"
        ? {
            message: error.message,
            stack: error.stack,
          }
        : undefined
    );
  }
});
